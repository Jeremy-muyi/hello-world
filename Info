
import os
import time
import logging
import tkinter as tk
from tkinter import filedialog
from PIL import Image
import fitz  # PyMuPDF
import comtypes.client
import pythoncom
import customtkinter as ctk
from datetime import datetime
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from logging.handlers import RotatingFileHandler

# 配置参数
class Config:
    DISPLAY_SECONDS = 10
    FOLDER_PATH = r"\\aq3nas01.ap.lilly.com\aq3nas_mfg.grp\ELM_Workspaces\AutoDisplay"
    LOG_FOLDER = r"\\aq3nas01.ap.lilly.com\aq3nas_mfg.grp\ELM_Workspaces\AutoDisplay\Log"
    BACKGROUND = r"\\aq3nas01.ap.lilly.com\aq3nas_mfg.grp\ELM_Workspaces\AutoDisplay\background.png"
    LOG_MAX_SIZE = 5 * 1024 * 1024  # 5MB
    LOG_BACKUP_COUNT = 5
    RETRY_INTERVAL = 3600  # 1小时
    MAX_RETRIES = 3

class FileChangeHandler(FileSystemEventHandler):
    """文件系统变更处理器"""
    def __init__(self, app):
        super().__init__()
        self.app = app

    def on_modified(self, event):
        """当检测到文件修改时刷新文件列表"""
        if not event.is_directory:
            self.app.refresh_file_list()

class InfoDisplayApp:
    def __init__(self, root):
        self.root = root
        self._init_ui()
        self._init_resources()
        self._init_file_monitor()
        self._init_logging()
        
    def _init_ui(self):
        """初始化用户界面"""
        self.root.attributes('-fullscreen', True)
        self.root.tk.call('tk', 'scaling', 2.0)  # 高DPI适配
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("blue")

        # 控制面板
        self.control_frame = ctk.CTkFrame(self.root, fg_color="#344955", height=40)
        self.control_frame.place(relx=0.5, y=0, anchor="n")
        
        # 控制按钮
        controls = [
            ("开始投屏", self.start_display, "blue"),
            ("结束投屏", self.stop_display, "red"),
            ("选择文件夹", self.choose_folder, "green"),
            ("退出程序", self.quit_program, "#a83232")
        ]
        for text, cmd, color in controls:
            btn = ctk.CTkButton(
                self.control_frame, 
                text=text, 
                command=cmd,
                height=32,
                corner_radius=20,
                fg_color=color
            )
            btn.pack(side="left", padx=10, pady=5)

        # 状态显示
        self.status_label = ctk.CTkLabel(
            self.control_frame, 
            text="状态：未开始", 
            text_color="white"
        )
        self.status_label.pack(side="right", padx=10)

        # 主显示区域
        self.label = ctk.CTkLabel(self.root, text="")
        self.label.pack(expand=True, fill="both")

        # 初始化默认背景
        self.show_background()
        self.root.after(1000, self._check_mouse_position)

    def _init_resources(self):
        """初始化资源"""
        self.files = []
        self.index = 0
        self.current_pdf = None
        self.pdf_page_index = 0
        self.is_running = False
        self.error_files = set()
        self.recent_failed = {}
        self.default_image = self._load_background()

    def _init_logging(self):
        """初始化日志系统"""
        self.logger = logging.getLogger("DisplayApp")
        self.logger.setLevel(logging.INFO)
        
        # 确保日志目录存在
        os.makedirs(Config.LOG_FOLDER, exist_ok=True)
        
        # 创建按天滚动的日志处理器
        handler = RotatingFileHandler(
            self._get_log_path(),
            maxBytes=Config.LOG_MAX_SIZE,
            backupCount=Config.LOG_BACKUP_COUNT,
            encoding='utf-8'
        )
        formatter = logging.Formatter('[%(asctime)s] %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def _init_file_monitor(self):
        """初始化文件监控"""
        self.observer = Observer()
        self.observer.schedule(
            FileChangeHandler(self),
            Config.FOLDER_PATH,
            recursive=True
        )
        self.observer.start()

    def _get_log_path(self):
        """获取当日日志文件路径"""
        date_str = datetime.now().strftime("%Y%m%d")
        return os.path.join(
            Config.LOG_FOLDER, 
            f"display_log_{date_str}.txt"
        )

    def _load_background(self):
        """加载背景图片"""
        try:
            img = Image.open(Config.BACKGROUND)
            return img.resize(
                (self.root.winfo_screenwidth(), 
                 self.root.winfo_screenheight()),
                Image.Resampling.LANCZOS
            )
        except Exception as e:
            self.logger.error(f"背景加载失败: {str(e)}")
            return None

    def refresh_file_list(self):
        """刷新文件列表"""
        if self.is_running:
            self.files = self._get_supported_files()
            self.logger.info("检测到文件变化，已刷新播放列表")

    def _get_supported_files(self):
        """获取支持的文件列表"""
        exts = {'.jpg', '.jpeg', '.png', '.bmp', '.pdf', '.ppt', '.pptx'}
        try:
            return sorted([
                os.path.join(Config.FOLDER_PATH, f)
                for f in os.listdir(Config.FOLDER_PATH)
                if os.path.splitext(f)[1].lower() in exts
            ])
        except Exception as e:
            self.logger.error(f"读取文件错误: {str(e)}")
            return []

    def show_background(self):
        """显示背景图片"""
        if self.default_image:
            img = ctk.CTkImage(
                light_image=self.default_image,
                size=self.default_image.size
            )
            self.label.configure(image=img)
            self.label.image = img

    def start_display(self):
        """开始播放"""
        if not self.is_running:
            self.is_running = True
            self.status_label.configure(text="状态：播放中")
            self.files = self._get_supported_files()
            self.index = 0
            self.error_files.clear()
            self.recent_failed.clear()
            self.root.after(3000, self._hide_controls)
            self._show_next()

    def stop_display(self):
        """停止播放"""
        self.is_running = False
        self.status_label.configure(text="状态：已停止")
        self.show_background()

    def choose_folder(self):
        """选择文件夹"""
        folder = filedialog.askdirectory(initialdir=Config.FOLDER_PATH)
        if folder:
            Config.FOLDER_PATH = folder
            self.stop_display()
            self.refresh_file_list()
            self.start_display()

    def _show_next(self):
        """显示下一个内容"""
        if not self.is_running or not self.files:
            return

        self._clean_expired_errors()
        filepath = self.files[self.index]

        if self._should_skip_file(filepath):
            self._prepare_next()
            return

        try:
            ext = os.path.splitext(filepath)[1].lower()
            if ext in ('.jpg', '.jpeg', '.png', '.bmp'):
                self._show_image(filepath)
            elif ext == '.pdf':
                self._handle_pdf(filepath)
            elif ext in ('.ppt', '.pptx'):
                self._play_ppt(filepath)
        except Exception as e:
            self._handle_error(filepath, e)
        finally:
            self._prepare_next()

    def _show_image(self, path):
        """显示图片文件"""
        img = Image.open(path).resize(
            (self.root.winfo_screenwidth(),
             self.root.winfo_screenheight()),
            Image.Resampling.LANCZOS
        )
        ctk_img = ctk.CTkImage(light_image=img, size=img.size)
        self.label.configure(image=ctk_img)
        self.label.image = ctk_img

    def _handle_pdf(self, path):
        """处理PDF文件"""
        if not self.current_pdf or self.current_pdf.name != path:
            if self.current_pdf:
                self.current_pdf.close()
            self.current_pdf = fitz.open(path)
            self.pdf_page_index = 0

        if self.pdf_page_index < len(self.current_pdf):
            page = self.current_pdf[self.pdf_page_index]
            pix = page.get_pixmap()
            img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
            img = img.resize(
                (self.root.winfo_screenwidth(),
                 self.root.winfo_screenheight()),
                Image.Resampling.LANCZOS
            )
            self.show_image(img)
            self.pdf_page_index += 1
        else:
            self.current_pdf.close()
            self.current_pdf = None

    def _play_ppt(self, path):
        """播放PPT文件"""
        pythoncom.CoInitialize()
        try:
            powerpoint = comtypes.client.CreateObject("Powerpoint.Application")
            pres = powerpoint.Presentations.Open(path, WithWindow=True)
            
            for slide in pres.Slides:
                slide.SlideShowTransition.AdvanceOnTime = True
                slide.SlideShowTransition.AdvanceTime = Config.DISPLAY_SECONDS
            
            slideshow = pres.SlideShowSettings.Run()
            start_time = time.time()
            
            while time.time() - start_time < Config.DISPLAY_SECONDS * len(pres.Slides):
                try:
                    if slideshow.View.State != 1:
                        break
                    time.sleep(1)
                except:
                    break
            
            pres.Close()
            powerpoint.Quit()
        except Exception as e:
            raise RuntimeError(f"PPT播放失败: {str(e)}")
        finally:
            pythoncom.CoUninitialize()

    def _handle_error(self, filepath, error):
        """处理播放错误"""
        self.logger.error(f"播放失败: {filepath} - {str(error)}")
        self.error_files.add(filepath)
        self.recent_failed[filepath] = {
            'count': self.recent_failed.get(filepath, {}).get('count', 0) + 1,
            'time': time.time()
        }
        self.show_background()

    def _clean_expired_errors(self):
        """清理过期错误记录"""
        now = time.time()
        expired = [
            k for k, v in self.recent_failed.items()
            if now - v['time'] > Config.RETRY_INTERVAL
        ]
        for f in expired:
            del self.recent_failed[f]

    def _should_skip_file(self, filepath):
        """判断是否应该跳过文件"""
        return (
            filepath in self.error_files or 
            self.recent_failed.get(filepath, {}).get('count', 0) >= Config.MAX_RETRIES
        )

    def _prepare_next(self):
        """准备下一个播放项"""
        if self.is_running:
            self.index = (self.index + 1) % len(self.files)
            self.root.after(
                Config.DISPLAY_SECONDS * 1000, 
                self._show_next
            )

    def _check_mouse_position(self):
        """检测鼠标位置控制面板显示"""
        try:
            y = self.root.winfo_pointery()
            if y < 50:
                self._show_controls()
            self.root.after(500, self._check_mouse_position)
        except:
            pass

    def _show_controls(self):
        """显示控制面板"""
        self.control_frame.lift()
        self.root.after(3000, self._hide_controls)

    def _hide_controls(self):
        """隐藏控制面板"""
        self.control_frame.lower()

    def quit_program(self):
        """退出程序"""
        self.logger.info("程序退出")
        self.observer.stop()
        self.observer.join()
        if self.current_pdf:
            self.current_pdf.close()
        self.root.destroy()

if __name__ == "__main__":
    root = ctk.CTk()
    app = InfoDisplayApp(root)
    root.mainloop()
